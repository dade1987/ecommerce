# Cursor Rules - Ecommerce Project

## Regola 1: Riutilizzo del Codice Prima dell'Invenzione

### Descrizione
Prima di scrivere nuovo codice, cerca sempre soluzioni esistenti nel codebase. Solo dopo aver verificato che non esiste nulla di adatto, si può proporre una nuova soluzione, ma solo previa conferma esplicita dell'utente.

### Check 1: Search Before Code
**PRIMA di scrivere qualsiasi codice nuovo, DEVI cercare nel codebase soluzioni esistenti per quello scopo.**

Suggerimenti:
- Usa codebase_search per cercare pattern simili, funzionalità esistenti, classi o metodi che già risolvono il problema.
- Cerca servizi, controller, modelli, traits, helpers o librerie esistenti che possano essere riutilizzati.
- Verifica se esistono già pattern architetturali consolidati nel progetto per quella funzionalità.
- Controlla se ci sono già middleware, validatori, form request o policy esistenti che possano essere adattati.

**Enforcement:** ERRORE - Blocca se violato

### Check 2: Reuse Existing Solutions
**Se esiste già una soluzione nel codebase, DEVI riutilizzarla o estenderla invece di crearne una nuova.**

Suggerimenti:
- Adatta e riutilizza codice esistente piuttosto che duplicarlo.
- Estendi classi esistenti invece di crearne di nuove se possibile.
- Usa servizi, helper o utility già presenti nel progetto.
- Segui i pattern e le convenzioni già stabilite nel codebase.

**Enforcement:** ERRORE - Blocca se violato

### Check 3: Ask Before Inventing
**Se dopo aver cercato non trovi soluzioni esistenti e devi inventare qualcosa di nuovo, DEVI chiedere conferma esplicita all'utente PRIMA di implementarlo.**

Suggerimenti:
- Presenta all'utente: 1) Cosa hai cercato, 2) Cosa hai trovato (o non trovato), 3) La tua proposta di nuova soluzione.
- Aspetta la conferma esplicita dell'utente prima di scrivere codice nuovo.
- Se l'utente non risponde, NON procedere con l'implementazione.
- Documenta perché la soluzione esistente non è adatta se ne esiste una.

**Enforcement:** ERRORE - Blocca se violato

### Check 4: Document Search Process
**Quando proponi una nuova soluzione, documenta sempre il processo di ricerca che hai fatto.**

Suggerimenti:
- Indica quali termini di ricerca hai usato.
- Elenca i file/classi che hai esaminato.
- Spiega perché le soluzioni esistenti non sono adatte al caso d'uso.
- Mostra esempi di codice esistente che hai considerato.

### Check 5: Verify Method Existence
**PRIMA di usare qualsiasi metodo, funzione o API, DEVI verificare che esista realmente nel codebase o nelle dipendenze del progetto.**

Suggerimenti:
- Usa grep o codebase_search per cercare la definizione del metodo prima di usarlo.
- Verifica la firma del metodo (parametri, tipo di ritorno) leggendo il codice sorgente.
- Controlla la documentazione delle classi usando read_file sul file che contiene il metodo.
- Per metodi di framework/librerie esterne, verifica la versione installata e la documentazione corrispondente.
- NON presumere che un metodo esista solo perché sembra logico che dovrebbe esistere.
- Se il metodo non esiste, cerca alternative esistenti o chiedi conferma prima di crearlo.
- Verifica anche metodi statici, magic methods, e metodi ereditati da classi parent.
- Per metodi di modelli Eloquent, verifica le relazioni e gli scope definiti nel modello.

**Enforcement:** ERRORE - Blocca se violato

### Check 6: Follow Software Engineering Principles
**DEVI sempre seguire i principi fondamentali di ingegneria del software: DRY, KISS, SOLID, YAGNI e altri principi importanti.**

Suggerimenti:
- **DRY (Don't Repeat Yourself):** Non duplicare codice. Estrai logica comune in funzioni, classi, traits o helper riutilizzabili.
- **KISS (Keep It Simple, Stupid):** Mantieni il codice semplice e leggibile. Evita soluzioni complesse quando una semplice funziona.
- **SOLID - Single Responsibility:** Ogni classe deve avere una sola responsabilità. Se una classe fa troppe cose, dividila.
- **SOLID - Open/Closed:** Le classi devono essere aperte per estensione ma chiuse per modifica. Usa ereditarietà e interfacce.
- **SOLID - Liskov Substitution:** Le classi derivate devono essere sostituibili con le loro classi base senza rompere il codice.
- **SOLID - Interface Segregation:** Crea interfacce specifiche invece di interfacce grandi. I client non devono dipendere da metodi che non usano.
- **SOLID - Dependency Inversion:** Dipendi da astrazioni (interfacce) non da implementazioni concrete. Usa Dependency Injection.
- **YAGNI (You Aren't Gonna Need It):** Non implementare funzionalità finché non sono realmente necessarie.
- **Principio di Least Surprise:** Il codice deve comportarsi come ci si aspetta. Nomi chiari, comportamento prevedibile.
- **Separation of Concerns:** Separa le responsabilità (presentazione, logica, dati) in componenti distinti.
- **Don't Optimize Prematurely:** Non ottimizzare prima di misurare. Scrivi codice chiaro prima, ottimizza solo se necessario.
- **Fail Fast:** Rileva e gestisci gli errori il prima possibile invece di propagarli silenziosamente.
- **Law of Demeter:** Un oggetto deve interagire solo con i suoi amici diretti, non con gli amici degli amici.
- **Composition over Inheritance:** Preferisci la composizione all'ereditarietà quando possibile.

**Enforcement:** ERRORE - Blocca se violato

### Check 7: Use Laravel Best Practices and Patterns
**DEVI sempre scegliere il pattern migliore per lo sviluppo considerando che si lavora in Laravel. Usa le funzionalità native di Laravel invece di reinventare la ruota.**

Suggerimenti:
- Per validazione: usa Form Request invece di validare manualmente nei controller.
- Per autorizzazione: usa Policy o Gate invece di logica custom nei controller.
- Per logica di business: usa Service classes o Action classes invece di metodi lunghi nei controller.
- Per eventi: usa il sistema di Event/Listener di Laravel invece di chiamate dirette.
- Per code: usa Job classes invece di eseguire operazioni pesanti nei controller.
- Per notifiche: usa Notification classes invece di inviare email direttamente.
- Per export/import: usa Laravel Excel o Export classes invece di generare file manualmente.
- Per query complesse: usa Query Builder, Eloquent Scopes o Repository pattern quando appropriato.
- Per cache: usa il sistema di cache di Laravel invece di variabili globali o sessioni.
- Per configurazione: usa config files invece di hardcoding valori.
- Per localizzazione: usa il sistema di traduzione di Laravel invece di stringhe hardcoded.
- Per file storage: usa Storage facade invece di funzioni file PHP native quando possibile.
- Per autenticazione: usa i middleware e guard di Laravel invece di logica custom.
- Per relazioni: usa le relazioni Eloquent invece di query manuali quando possibile.
- Per observer: usa Model Observers invece di hook manuali nei controller.
- Verifica sempre se Laravel offre una soluzione nativa prima di implementare qualcosa di custom.
- Segui le convenzioni di naming di Laravel (PascalCase per classi, camelCase per metodi, snake_case per tabelle).
- Usa Dependency Injection invece di istanziare classi direttamente.
- Per test: usa le funzionalità di testing di Laravel (Factories, Seeders, Assertions) invece di creare dati manualmente.

**Enforcement:** ERRORE - Blocca se violato

### Check 8: No Asynchronous JavaScript Code
**È VIETATO usare codice asincrono in JavaScript. Non usare setTimeout, setInterval, async/await, Promise, fetch con async, o qualsiasi altra forma di codice asincrono.**

**Scope:** `**/*.js`, `**/*.jsx`, `resources/**/*.js`

Suggerimenti:
- Usa codice sincrono invece di setTimeout o setInterval.
- Per operazioni che richiedono attesa, usa callback o gestisci l'evento direttamente.
- Non usare async/await nelle funzioni JavaScript.
- Non usare Promise o .then() per gestire operazioni asincrone.
- Per chiamate AJAX, usa jQuery.ajax con success/error callbacks invece di fetch con async/await.
- Se devi eseguire codice dopo un evento, usa gli event listener invece di setTimeout.
- Per animazioni, usa CSS transitions/animations invece di setTimeout per aggiornamenti.
- Se hai bisogno di ritardare l'esecuzione, usa eventi DOM o callback invece di timeout.

Pattern vietati:
- `setTimeout`
- `setInterval`
- `async function`
- `async (`
- `await `
- `new Promise`
- `.then(`
- `.catch(`
- `.finally(`
- `fetch(`
- `async/await`

**Enforcement:** ERRORE - Blocca se violato

---

## Regola 2: Standard di Qualità Laravel - Testing di Alta Qualità

### Descrizione
Standard di qualità per progetti Laravel: test completi, alta coverage, validazione Larastan e persistenza dei dati.

**Scope:** `app/**/*.php`, `tests/**/*.php`

### Check 1: Verify Project Structure Before Testing
**PRIMA di scrivere qualsiasi test, DEVI verificare la struttura reale del progetto. NON presumere nomi di tabelle, modelli, relazioni o come il sistema gestisce le entità.**

Suggerimenti:
- Cerca il modello Eloquent corrispondente (es. Company, User, ecc.) per verificare il nome della tabella.
- Verifica le migration per capire la struttura delle tabelle e i nomi effettivi.
- Leggi il codice esistente per capire come il sistema gestisce le entità (es. come vengono recuperate le companies).
- Cerca factory esistenti per vedere come vengono creati i dati di test.
- Verifica relazioni, foreign key e vincoli nel database.
- Controlla i seeder esistenti per capire come vengono popolati i dati.
- NON inventare nomi di tabelle o modelli senza averli verificati nel codebase.
- Usa codebase_search per trovare esempi di test esistenti che testano entità simili.
- PRIMA di usare qualsiasi metodo nelle asserzioni o nel setup, verifica che esista realmente (vedi regola 'Verify Method Existence').
- Verifica che i metodi delle classi di test (assert*, be*, actingAs*, ecc.) siano quelli corretti per la versione di Laravel/PHPUnit in uso.

**Enforcement:** ERRORE - Blocca se violato

### Check 2: Development Discipline
**Ogni sviluppo o modifica deve includere un test unit o feature coerente.**

Suggerimenti:
- Ogni classe o feature nuova deve avere una classe di test in tests/Unit o tests/Feature con nome coerente.
- Esempio: `app/Services/UserService.php` → `tests/Unit/Services/UserServiceTest.php`

**Enforcement:** ERRORE - Blocca se violato

### Check 3: Larastan Validation
**Prima di ogni commit deve essere eseguito phpstan (Larastan) con livello minimo 8.**

Suggerimenti:
- Esegui: `vendor/bin/phpstan analyse --level=max app/ tests/`
- Correggi tutti gli errori prima di pushare.

**Enforcement:** ERRORE - Blocca se violato

### Check 4: Database Persistence
**Non usare RefreshDatabase o DatabaseTransactions: i dati devono restare nel DB per verifica manuale.**

Pattern vietati:
- `use RefreshDatabase`
- `use DatabaseTransactions`

### Check 5: No Mocks - Real Testing Only
**È VIETATO usare mock, stub, fake o qualsiasi forma di simulazione nei test. I test devono testare solo casi reali con dati reali e interazioni reali.**

Suggerimenti:
- Usa dati reali creati con factory o seeder invece di mockare oggetti.
- Testa le interazioni reali con il database, servizi esterni e componenti del sistema.
- Se devi testare chiamate HTTP esterne, usa un server di test reale o configurazioni di test reali.
- Per servizi esterni, crea dati di test reali o usa ambienti di test reali invece di mockare le risposte.
- I test devono riflettere il comportamento reale del sistema in produzione.
- Usa faker per generare dati realistici ma reali, non mock per simulare comportamenti.

Pattern vietati:
- `Mockery::mock`
- `->mock(`
- `->shouldReceive`
- `->shouldReturn`
- `->shouldNotReceive`
- `Mock::`
- `createMock`
- `getMock`
- `->willReturn`
- `->willThrowException`
- `->expects(`
- `->method(`
- `->with(`
- `->andReturn`
- `->andThrow`
- `->andReturnUsing`
- `->fake()`
- `Fake::`
- `Http::fake`
- `Mail::fake`
- `Notification::fake`
- `Queue::fake`
- `Storage::fake`
- `Event::fake`
- `Bus::fake`

**Enforcement:** ERRORE - Blocca se violato

### Check 6: Test Naming Convention
**Il nome del metodo di test deve descrivere chiaramente il comportamento previsto.**

Pattern richiesti:
- `public function test_`

Suggerimenti:
- Esempio: `public function test_creates_user_successfully()`
- Esempio: `public function test_fails_when_email_is_invalid()`

### Check 7: Assertion Requirements
**Ogni test deve includere almeno una asserzione di stato e una di contenuto/logica.**

Pattern richiesti:
- `assert(Status|See|Database|Json|Redirect)`

**Minimo:** 2 asserzioni per test

### Check 8: Edge Case and Error Flow
**Per ogni caso positivo testato, deve esserci almeno un caso di errore o edge case.**

Suggerimenti:
- Aggiungi test per input nulli, duplicati, valori limite, accessi non autorizzati o eccezioni.
- Simula condizioni di errore nei servizi e verifica la gestione corretta.

### Check 9: Code Style and AAA Pattern
**Usa sempre la struttura Arrange-Act-Assert per leggibilità e consistenza.**

Suggerimenti:
```php
// Arrange
// Act
// Assert
```

### Check 10: Mutation Resistance
**I test devono fallire se la logica del codice viene alterata. Usa Infection PHP per verificarlo.**

Suggerimenti:
- `composer require infection/infection --dev`
- `vendor/bin/infection --min-msi=90`

### Check 11: Code Coverage Enforcement
**La coverage dei test deve essere ≥ 90% su app/ e tests/.**

Suggerimenti:
- `php artisan test --coverage --min=90`

### Check 12: Manual Inspection Allowance
**I test devono lasciare i record nel database per consentire l'analisi manuale.**

Suggerimenti:
- Usa factory controllate o DatabaseSeeder per popolare i dati.
- Non usare teardown o truncate automatici.

### Check 13: Dev Safety (Pre-Commit Check)
**Il commit viene bloccato se non superi i controlli di qualità essenziali.**

Suggerimenti:
Prima del commit, assicurati che:
1️⃣ Tutti i test passino → `php artisan test`
2️⃣ Larastan sia pulito → `vendor/bin/phpstan analyse --level=max app/ tests/`
3️⃣ Coverage ≥ 90% → `php artisan test --coverage`
4️⃣ Nessuna violazione di regole in questo file

Solo dopo questi step è consentito il commit.

**Enforcement:** ERRORE - Blocca se violato

---

## Regola 3: Sicurezza delle Applicazioni (AppSec) e Cultura - Shift Everywhere

### Descrizione
Sicurezza delle Applicazioni (AppSec) e Cultura: sicurezza integrata in tutte le fasi dello sviluppo con approccio Shift Everywhere.

**Scope:** `**/*`

### Check 1: Security-First Mindset
**La sicurezza deve essere una mentalità radicata (security-first mindset) e non un ripensamento. La sicurezza è un problema di persone, non solo tecnico.**

Suggerimenti:
- Pensa alla sicurezza fin dall'inizio del design, non come aggiunta successiva.
- Considera la sicurezza come parte integrante del processo di sviluppo, non come fase separata.
- Forma il team con conoscenze specifiche per lo stack tecnologico utilizzato per evitare codice vulnerabile.

**Enforcement:** ERRORE - Blocca se violato

### Check 2: SSDLC Proattivo
**Adotta un Ciclo di Vita di Sviluppo Software Sicuro (SSDLC), integrando la sicurezza in tutte le fasi, dalla concezione alla distribuzione.**

Suggerimenti:
- Integra controlli di sicurezza in ogni fase dello sviluppo.
- Il costo di correggere i difetti cresce esponenzialmente se affrontati tardi.
- Applica Shift Everywhere: sposta i controlli di sicurezza ovunque nello SDLC, non solo a sinistra.

**Enforcement:** ERRORE - Blocca se violato

### Check 3: Prioritizzazione basata sul Rischio
**Concentrati sui problemi di sicurezza che rappresentano i rischi più significativi in base al threat model e al contesto di business.**

Suggerimenti:
- Conduci Threat Modeling per identificare minacce e vulnerabilità, idealmente all'inizio del progetto e continuamente.
- Prioritizza le vulnerabilità in base al rischio reale per il business.
- Non è possibile risolvere tutti i problemi in una volta sola.

### Check 4: Zero Trust Architecture
**Implementa l'architettura Zero Trust (ZTA) assumendo sempre la compromissione (assume breach) e verificando esplicitamente identità e integrità.**

Suggerimenti:
- Verifica sempre l'identità e l'integrità di utenti e componenti ogni volta che attraversano un confine di sicurezza.
- Non fidarti mai implicitamente di richieste o dati.
- Applica il principio del minimo privilegio (Least Privilege): concedi solo le autorizzazioni necessarie, per il tempo necessario.

**Enforcement:** ERRORE - Blocca se violato

### Check 5: Defense in Depth
**Usa la difesa in profondità (DiD), applicando controlli di sicurezza a più livelli per minimizzare il raggio d'azione di un attacco.**

Suggerimenti:
- Implementa controlli di sicurezza a livello di rete, applicazione, database e accesso.
- Non fare affidamento su un singolo livello di sicurezza.
- Ogni livello deve essere in grado di resistere a un attacco indipendentemente dagli altri.

### Check 6: Validazione degli Input
**Non fidarti mai degli input. Tutte le applicazioni sono gateways per i dati; è fondamentale convalidare e sanificare rigorosamente gli input.**

Suggerimenti:
- Valida e sanifica TUTTI gli input utente per prevenire attacchi di iniezione (SQLi, XSS, Command Injection).
- Usa Form Request di Laravel per validazione strutturata.
- Applica whitelist invece di blacklist quando possibile.
- Escape output per prevenire XSS.

**Enforcement:** ERRORE - Blocca se violato

### Check 7: Automazione della Sicurezza
**Automatizza i controlli di sicurezza (SAST, DAST, SCA) nelle pipeline CI/CD. Applica Policy-as-Code (PaC).**

Suggerimenti:
- Integra SAST (Static Application Security Testing) nella pipeline CI/CD.
- Esegui scansioni automatiche delle dipendenze (SCA - Software Composition Analysis).
- Implementa Policy-as-Code: nessun codice con vulnerabilità critiche deve essere distribuito in produzione.
- Usa strumenti come Larastan, PHPStan, SonarQube per analisi statica.

### Check 8: Gestione Segreti
**Utilizza sistemi maturi per la gestione dei segreti (secrets management) e automatizza la rotazione delle credenziali.**

Suggerimenti:
- Mai hardcodare password, API keys o token nel codice.
- Usa variabili d'ambiente o sistemi di gestione segreti (es. HashiCorp Vault, AWS Secrets Manager).
- Automatizza la rotazione periodica delle credenziali.
- Non committare file .env nel repository.

**Enforcement:** ERRORE - Blocca se violato

### Check 9: Security Paved Roads
**Fornisci strumenti di sicurezza che si integrino bene con il flusso di lavoro dello sviluppatore e che siano facili da usare (developer empathy).**

Suggerimenti:
- Crea Security Paved Roads per rendere la sicurezza predefinita e trasparente per lo sviluppatore.
- Rendi facile fare la cosa giusta e difficile fare la cosa sbagliata.
- Integra controlli di sicurezza nel workflow senza rallentare lo sviluppo.

### Check 10: Gestione della Supply Chain
**Utilizza l'analisi della composizione del software (SCA) e gli SBOM (Software Bill of Materials) per gestire il rischio della catena di fornitura software.**

Suggerimenti:
- Monitora le dipendenze open source per vulnerabilità note.
- Mantieni aggiornate le dipendenze con patch di sicurezza.
- Usa composer audit o strumenti simili per verificare vulnerabilità nelle dipendenze.
- Documenta le dipendenze e le loro versioni.

---

## Regola 4: Domain-Driven Design per il Monolite Modulare

### Descrizione
Domain-Driven Design per il Monolite Modulare: partizionamento per dominio, Bounded Contexts, Linguaggio Ubiquo e comunicazione tramite API.

**Scope:** `app/**/*.php`, `src/**/*.php`

### Check 1: Partizionamento per Dominio
**Il Monolite Modulare deve essere partizionato in base al dominio aziendale o ai flussi di lavoro, non in base alle capacità tecniche.**

Suggerimenti:
- Evita il partizionamento tecnico (presentazione, logica, persistenza) che 'spalma' il dominio su tutti gli strati.
- Raggruppa codice per dominio di business (es. Assignment, LegalPractice, User, ecc.).
- Ogni modulo deve rappresentare un Bounded Context con un modello di dominio coerente.

**Enforcement:** ERRORE - Blocca se violato

### Check 2: Bounded Contexts come Moduli
**Ogni modulo all'interno del monolite deve rappresentare un Bounded Context con confine linguistico e semantico ben definito.**

Suggerimenti:
- Un Bounded Context definisce un confine in cui un singolo modello di dominio è coerente e applicabile.
- Evita di condividere modelli di dominio tra Bounded Context diversi.
- Ogni modulo deve avere la propria comprensione del dominio.

**Enforcement:** ERRORE - Blocca se violato

### Check 3: Linguaggio Ubiquo
**Sviluppa un Linguaggio Ubiquo condiviso con gli esperti di dominio, privo di gergo tecnico, riflesso nel codice.**

Suggerimenti:
- Usa termini del dominio di business nei nomi di classi, metodi e variabili.
- Evita termini tecnici generici quando esistono termini di dominio specifici.
- Il linguaggio deve essere coerente tra codice, test e documentazione.
- Coinvolgi esperti di dominio nella definizione del linguaggio.

**Enforcement:** ERRORE - Blocca se violato

### Check 4: Alta Coesione e Basso Accoppiamento
**I moduli devono avere alta coesione funzionale (raggruppare dati e comportamenti che cambiano insieme) e basso accoppiamento tra di loro.**

Suggerimenti:
- Raggruppa dati e comportamenti che cambiano insieme nello stesso modulo.
- Minimizza le dipendenze tra moduli.
- L'obiettivo del Monolite Modulare è l'incapsulamento.

**Enforcement:** ERRORE - Blocca se violato

### Check 5: Proprietà Esclusiva dei Dati
**Ciascun modulo (BC) deve possedere esclusivamente i propri dati. Nessun altro modulo deve accedere direttamente al database del modulo proprietario.**

Suggerimenti:
- Evita il Common Coupling: non condividere tabelle o database tra moduli.
- Ogni modulo ha il proprio schema di database o namespace di tabelle.
- L'accesso ai dati di un modulo deve avvenire solo tramite le API pubbliche del modulo.

**Enforcement:** ERRORE - Blocca se violato

### Check 6: Comunicazione tramite API/Contratti
**La comunicazione tra i moduli deve avvenire tramite interfacce ben definite (API pubbliche o interfacce di servizio).**

Suggerimenti:
- Definisci contratti chiari tra moduli tramite interfacce o classi DTO.
- Le modifiche ai dettagli interni di implementazione (come lo schema del database) non devono propagarsi all'esterno.
- Usa Application Services o Service Classes per esporre funzionalità pubbliche del modulo.
- Evita dipendenze dirette su implementazioni concrete di altri moduli.

**Enforcement:** ERRORE - Blocca se violato

### Check 7: Riferimenti tramite ID
**Per ridurre l'accoppiamento, i moduli devono fare riferimento ad altri componenti (aggregati) in contesti esterni solo tramite ID.**

Suggerimenti:
- Non passare oggetti complessi tra moduli, usa solo ID primitivi.
- Se serve più informazione, usa DTO o Value Objects leggeri.
- Evita riferimenti diretti a modelli Eloquent di altri moduli.

**Enforcement:** ERRORE - Blocca se violato

### Check 8: Protezione del Core Domain
**Investi risorse e attenzione di design sui Core Subdomains (il vantaggio competitivo) e usa pattern più semplici per Supporting e Generic Subdomains.**

Suggerimenti:
- Identifica quali parti del sistema sono Core Domain (vantaggio competitivo).
- Per Core Domains complessi: usa Domain Model, Aggregati, Value Objects, Domain Services.
- Per Supporting/Generic Subdomains: usa pattern più semplici come Transaction Script o Active Record.
- Non sovra-ingegnerizzare parti non critiche del sistema.

### Check 9: Anticorruption Layer per Legacy
**Quando un modulo deve interagire con un sistema esterno o legacy mal progettato, implementa un Anticorruption Layer (ACL) per proteggere il modello interno.**

Suggerimenti:
- Crea un layer di traduzione tra il sistema legacy e il tuo modello di dominio.
- L'ACL protegge il Core Domain dalla propagazione di concetti stranieri o cambiamenti frequenti.
- Isola la complessità del sistema legacy in un modulo dedicato.
- Usa Adapter pattern per tradurre tra i due modelli.

### Check 10: Pattern Moduli src/Modules
**Quando crei un nuovo modulo, DEVI seguire il pattern già stabilito in src/Modules, come dimostrato dai moduli esistenti (DataImporter, DataShare, Sharepoint).**

Suggerimenti:
- Crea il modulo in src/Modules/{ModuleName}/ seguendo la struttura standardizzata.
- Struttura richiesta: Providers/{ModuleName}ServiceProvider.php, routes/, Http/Controllers/, Http/Middleware/, Http/Requests/, Services/, Models/, Contracts/, Traits/, config/, database/migrations/, resources/views/.
- Il ServiceProvider deve registrare: config (mergeConfigFrom), middleware (aliasMiddleware), routes (loadRoutesFrom), migrations (loadMigrationsFrom), views (loadViewsFrom), commands se necessario.
- Usa namespace Src\\Modules\\{ModuleName}\\ per tutte le classi del modulo.
- Le routes devono essere definite in routes/{modulename}_routes.php e caricate dal ServiceProvider.
- Il modulo deve essere abilitato/disabilitato tramite config('application.modules.{module_name}') nel ServiceProvider::boot().
- Consulta i moduli esistenti (es. DataImporter) come riferimento per la struttura completa.
- Ogni modulo deve essere autocontenuto con le proprie dipendenze, configurazioni e risorse.

**Enforcement:** ERRORE - Blocca se violato

---

## Regola 5: Pattern di Implementazione e Qualità del Codice

### Descrizione
Pattern di Implementazione e Qualità del Codice: Ports & Adapters, Domain Model, CQRS, IoC e governance sulla modularità.

**Scope:** `app/**/*.php`, `src/**/*.php`

### Check 1: Ports & Adapters Architecture
**Adotta l'architettura Ports & Adapters (Hexagonal) all'interno dei moduli complessi (Core Domains).**

Suggerimenti:
- Inverti la dipendenza: isola la logica di business (Domain Model o Inner Core) dai dettagli di infrastruttura.
- Definisci Port (interfacce) per le dipendenze esterne (database, UI, servizi esterni).
- Implementa Adapters per le implementazioni concrete (Eloquent, HTTP clients, ecc.).
- Il Domain Model non deve dipendere da framework o librerie di infrastruttura.

**Enforcement:** ERRORE - Blocca se violato

### Check 2: Domain Model nel Core
**Utilizza il pattern Domain Model (Aggregati, Value Objects, Domain Services) per i Core Subdomains con logica di business complessa e invarianti.**

Suggerimenti:
- Ports & Adapters è un requisito per implementare efficacemente un Domain Model.
- Raggruppa entità correlate in Aggregati con invarianti ben definite.
- Usa Value Objects per concetti del dominio che non hanno identità propria.
- Sposta la logica di business nel Domain Model, non negli Application Services.

**Enforcement:** ERRORE - Blocca se violato

### Check 3: Evita Layered Architecture per Dominio Complesso
**La tradizionale Architettura a Strati (Layered Architecture) è sconsigliata per i Core Domains complessi.**

Suggerimenti:
- La Layered Architecture accoppia la logica di business all'infrastruttura (Data Access Layer).
- Rende difficili i cambiamenti basati sul dominio.
- Preferisci Ports & Adapters per Core Domains complessi.

### Check 4: CQRS per Data Read Complessi
**Considera l'adozione di CQRS (Command-Query Responsibility Segregation) se sono richieste più rappresentazioni dei dati o esigenze analitiche/prestazionali.**

Suggerimenti:
- Separa modelli di scrittura (Command) da modelli di lettura (Query).
- Usa CQRS quando un singolo modello non può soddisfare tutte le esigenze (Polyglot Modeling/Persistence).
- Non applicare CQRS ovunque: solo dove necessario per complessità o performance.
- In Laravel, considera Query Builders dedicati o viste materializzate per query complesse.

### Check 5: Inversione di Controllo (IoC)
**Sfrutta i container di Dependency Injection (DI) di Laravel per implementare il principio di Inversione di Controllo (IoC).**

Suggerimenti:
- Usa Dependency Injection invece di istanziare classi direttamente.
- Dipendi da interfacce (astrazioni) non da implementazioni concrete.
- Registra binding nel Service Provider di Laravel.
- Il container DI facilita il decoupling e la testabilità.

**Enforcement:** ERRORE - Blocca se violato

### Check 6: Application Services per Orchestrazione
**Utilizza gli Application Services (o classi Action) come strato per orchestrare i use cases e gestire le transazioni, ma NON devono contenere la logica di business.**

Suggerimenti:
- Gli Application Services orchestrano chiamate a Domain Services, Repository, Eventi.
- Gestiscono transazioni e coordinamento tra componenti.
- La logica di business deve risiedere nel Domain Model, non negli Application Services.
- Mantieni gli Application Services sottili: delegano al Domain Model.

**Enforcement:** ERRORE - Blocca se violato

### Check 7: Test e Validazione
**Sviluppa test rigorosi (unit, integrazione) per convalidare il modello di dominio e le misure di sicurezza.**

Suggerimenti:
- L'alto isolamento dei moduli Ports & Adapters facilita i test.
- Testa il Domain Model in isolamento usando mock degli Adapters.
- Testa gli Application Services con test di integrazione.
- Valida anche le misure di sicurezza nei test.

### Check 8: Governance sulla Modularità
**Implementa strumenti di governance e Fitness Functions (es. test automatizzati di dipendenza) per mantenere i confini del modulo.**

Suggerimenti:
- Poiché le dipendenze tra moduli in un monolite non sono imposte a livello di processo, serve governance.
- Crea test automatizzati che verificano che i moduli non violino i confini.
- Usa strumenti come deptrac o archunit per verificare architettura.
- Evita che il monolite si trasformi in un Big Ball of Mud (BBOM).
- Documenta i confini dei moduli e le regole di comunicazione.

**Enforcement:** ERRORE - Blocca se violato


